"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var metric_1 = __importDefault(require("./metric"));
var Levenshtein = /** @class */ (function (_super) {
    __extends(Levenshtein, _super);
    function Levenshtein(name) {
        if (name === void 0) { name = 'Levenshtein'; }
        return _super.call(this, name) || this;
    }
    Levenshtein.prototype.distance = function (source, target, _a) {
        var _b = _a === void 0 ? {} : _a, deletionCost = _b.deletionCost, insertionCost = _b.insertionCost, substitutionCost = _b.substitutionCost;
        var sourceLength = source.length;
        var targetLength = target.length;
        var removeCost = deletionCost !== null && deletionCost !== void 0 ? deletionCost : 1;
        var insertCost = insertionCost !== null && insertionCost !== void 0 ? insertionCost : 1;
        var subtractCost = substitutionCost !== null && substitutionCost !== void 0 ? substitutionCost : 1;
        var rows = sourceLength + 1;
        var cols = targetLength + 1;
        var distanceMatrix = Array(cols).fill(0).map(function () { return Array(rows).fill(0); });
        for (var i = 0; i <= sourceLength; i++) {
            distanceMatrix[0][i] = i * removeCost;
        }
        for (var j = 0; j <= targetLength; j++) {
            distanceMatrix[j][0] = j * insertCost;
        }
        for (var j = 1; j <= targetLength; j++) {
            for (var i = 1; i <= sourceLength; i++) {
                var indicator = 0;
                if (source[i - 1] !== target[j - 1]) {
                    indicator += subtractCost;
                }
                distanceMatrix[j][i] = Math.min(distanceMatrix[j][i - 1] + removeCost, distanceMatrix[j - 1][i] + insertCost, distanceMatrix[j - 1][i - 1] + indicator);
            }
        }
        return distanceMatrix[targetLength][sourceLength];
    };
    Levenshtein.prototype.maxDistance = function (source, target, _a) {
        var _b = _a === void 0 ? {} : _a, deletionCost = _b.deletionCost, insertionCost = _b.insertionCost, substitutionCost = _b.substitutionCost, _c = _b.cost, cost = _c === void 0 ? 1 : _c;
        var sourceLength = source.length;
        var targetLength = target.length;
        var delCost = deletionCost !== null && deletionCost !== void 0 ? deletionCost : cost;
        var insCost = insertionCost !== null && insertionCost !== void 0 ? insertionCost : cost;
        var subCost = substitutionCost !== null && substitutionCost !== void 0 ? substitutionCost : cost;
        var maxDel = Math.max(sourceLength - targetLength, 0);
        var maxIns = Math.max(targetLength - sourceLength, 0);
        var maxSub = Math.min(sourceLength, targetLength);
        return maxDel * delCost + maxIns * insCost + maxSub * subCost;
    };
    return Levenshtein;
}(metric_1.default));
exports.default = Levenshtein;
