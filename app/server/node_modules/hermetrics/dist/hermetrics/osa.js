"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var levenshtein_1 = __importDefault(require("./levenshtein"));
var OSA = /** @class */ (function (_super) {
    __extends(OSA, _super);
    function OSA(name) {
        if (name === void 0) { name = 'OSA'; }
        return _super.call(this, name) || this;
    }
    OSA.prototype.distance = function (source, target, _a) {
        var _b = _a === void 0 ? {} : _a, deletionCost = _b.deletionCost, insertionCost = _b.insertionCost, substitutionCost = _b.substitutionCost, transpositionCost = _b.transpositionCost, _c = _b.cost, cost = _c === void 0 ? 1 : _c;
        var sourceLength = source.length;
        var targetLength = target.length;
        var removeCost = deletionCost !== null && deletionCost !== void 0 ? deletionCost : cost;
        var insertCost = insertionCost !== null && insertionCost !== void 0 ? insertionCost : cost;
        var subtractCost = substitutionCost !== null && substitutionCost !== void 0 ? substitutionCost : cost;
        var transposCost = transpositionCost !== null && transpositionCost !== void 0 ? transpositionCost : cost;
        var rows = sourceLength + 1;
        var cols = targetLength + 1;
        var distanceMatrix = Array(rows).fill(0).map(function () { return Array(cols).fill(0); });
        for (var i = 1; i < rows; i++) {
            distanceMatrix[i][0] = i * removeCost;
        }
        for (var i = 1; i < cols; i++) {
            distanceMatrix[0][i] = i * insertCost;
        }
        var deletion = 0;
        var insertion = 0;
        var substitution = 0;
        for (var i = 1; i < rows; i++) {
            for (var j = 1; j < cols; j++) {
                deletion = distanceMatrix[i - 1][j] + removeCost;
                insertion = distanceMatrix[i][j - 1] + insertCost;
                substitution = distanceMatrix[i - 1][j - 1];
                if (source[i - 1] !== target[j - 1]) {
                    substitution += subtractCost;
                }
                distanceMatrix[i][j] = Math.min(deletion, insertion, substitution);
                if (i > 1 && j > 1 && source[i - 1] === target[j - 2] && source[i - 2] === target[j - 1]) {
                    distanceMatrix[i][j] = Math.min(distanceMatrix[i][j], distanceMatrix[i - 2][j - 2] + transposCost);
                }
            }
        }
        return distanceMatrix[rows - 1][cols - 1];
    };
    /**
       *
       * @param source
       * @param target
       * @param param2
       */
    OSA.prototype.maxDistance = function (source, target, _a) {
        var _b = _a === void 0 ? {} : _a, deletionCost = _b.deletionCost, insertionCost = _b.insertionCost, substitutionCost = _b.substitutionCost, _c = _b.cost, cost = _c === void 0 ? 1 : _c;
        return _super.prototype.maxDistance.call(this, source, target, { deletionCost: deletionCost, insertionCost: insertionCost, substitutionCost: substitutionCost, cost: cost });
    };
    OSA.prototype.maxDistanceWithTranspositions = function (source, target, _a) {
        var _b = _a === void 0 ? {} : _a, deletionCost = _b.deletionCost, insertionCost = _b.insertionCost, substitutionCost = _b.substitutionCost, transpositionCost = _b.transpositionCost, _c = _b.cost, cost = _c === void 0 ? 1 : _c;
        var sourceLength = source.length;
        var targetLength = target.length;
        var removeCost = deletionCost !== null && deletionCost !== void 0 ? deletionCost : cost;
        var insertCost = insertionCost !== null && insertionCost !== void 0 ? insertionCost : cost;
        var subtractCost = substitutionCost !== null && substitutionCost !== void 0 ? substitutionCost : cost;
        var transposCost = transpositionCost !== null && transpositionCost !== void 0 ? transpositionCost : cost;
        subtractCost = Math.min(subtractCost, removeCost + insertCost);
        transposCost = Math.min(transposCost, subtractCost * 2);
        var maxDel = Math.max(sourceLength - targetLength, 0);
        var maxIns = Math.max(targetLength - sourceLength, 0);
        var maxSub = Math.min(sourceLength, targetLength);
        var maxTra = Math.trunc(maxSub / 2);
        var delDist = maxDel * removeCost;
        var insDist = maxIns * insertCost;
        var subDist = maxSub * subtractCost;
        var traDist = maxTra * transposCost;
        return delDist + insDist + Math.min(subDist, traDist);
    };
    return OSA;
}(levenshtein_1.default));
exports.default = OSA;
